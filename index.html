<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IntelliWrite Document Reviewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Libraries for file reading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.5.1/mammoth.browser.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #editor { outline: none; white-space: pre-wrap; word-wrap: break-word; min-height: 40vh; }
        .highlight { border-radius: 3px; padding: 1px 0; cursor: pointer; }
        .highlight-spell { background-color: rgba(255, 219, 219, 0.8); border-bottom: 2px dotted #ef4444; }
        .highlight-grammar { background-color: rgba(219, 234, 254, 0.8); border-bottom: 2px dotted #3b82f6; }
        .highlight-fact { background-color: rgba(222, 247, 222, 0.8); border-bottom: 2px dotted #10b981; }
        .tooltip { position: absolute; display: none; background-color: #1f2937; color: white; padding: 10px; border-radius: 8px; z-index: 100; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 300px; }
        .tooltip-arrow { position: absolute; bottom: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: transparent transparent #1f2937 transparent; }
        .suggestion-btn { background-color: #374151; color: #d1d5db; padding: 4px 8px; border-radius: 4px; margin-top: 8px; margin-right: 4px; border: 1px solid #4b5563; }
        .suggestion-btn:hover { background-color: #4b5563; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .api-key-bar { transition: background-color 0.3s; }
        #fileUploadLabel { cursor: pointer; }
        #progressBar { transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-6">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">IntelliWrite Document Reviewer</h1>
            <p class="text-gray-600 mt-2">Upload a .docx or .pdf file to begin your AI-powered review.</p>
        </header>
        
        <div id="apiKeySection" class="api-key-bar bg-red-100 border border-red-300 p-4 rounded-lg mb-6 shadow-sm">
             <div class="flex flex-col sm:flex-row sm:items-center gap-3">
                <div class="flex-grow">
                    <label for="apiKeyInput" class="block font-semibold text-red-800 mb-1">API Key Required</label>
                    <input type="password" id="apiKeyInput" placeholder="Paste your Google AI API Key here" class="w-full p-2 border border-red-300 rounded-md focus:ring-2 focus:ring-red-400 focus:outline-none">
                </div>
                <button id="saveApiKeyBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md transition-transform transform hover:scale-105 self-start sm:self-end">Save Key</button>
            </div>
            <p id="apiKeyStatus" class="text-sm text-red-700 mt-2">To use the AI features, you need a free Google AI API key. <a href="https://aistudio.google.com/app/apikey" target="_blank" class="font-semibold underline hover:text-red-800">Get one here.</a></p>
        </div>

        <!-- File Upload Section -->
        <div class="bg-white rounded-xl shadow-lg p-4 sm:p-6 md:p-8 mb-6">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">1. Upload Document</h2>
            <div class="flex items-center justify-center w-full">
                <label for="fileUpload" id="fileUploadLabel" class="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg bg-gray-50 hover:bg-gray-100">
                    <div class="flex flex-col items-center justify-center pt-5 pb-6">
                        <svg class="w-8 h-8 mb-2 text-gray-500" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/></svg>
                        <p class="mb-2 text-sm text-gray-500"><span class="font-semibold">Click to upload</span> or drag and drop</p>
                        <p class="text-xs text-gray-500">DOCX or PDF</p>
                    </div>
                    <input id="fileUpload" type="file" class="hidden" accept=".pdf,.docx" />
                </label>
            </div>
            <!-- NEW: Progress Bar -->
            <div id="progressContainer" class="w-full bg-gray-200 rounded-full h-2.5 mt-3 hidden">
                <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="fileName" class="text-center text-gray-600 mt-3 font-medium"></p>
        </div>

        <main class="bg-white rounded-xl shadow-lg p-4 sm:p-6 md:p-8">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">2. Review & Analyze</h2>
            <div class="flex flex-wrap gap-2 md:gap-4 border-b border-gray-200 pb-4 mb-4">
                <button id="checkGrammarBtn" class="action-btn flex-1 sm:flex-none bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">Grammar & Style</button>
                <button id="plagiarismBtn" class="action-btn flex-1 sm:flex-none bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">Plagiarism Check</button>
                <button id="factCheckBtn" class="action-btn flex-1 sm:flex-none bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">Fact-Check</button>
                <button id="summarizeBtn" class="action-btn flex-1 sm:flex-none bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">✨ Summarize</button>
                <!-- NEW: Read Aloud Button -->
                <button id="readAloudBtn" class="action-btn flex-1 sm:flex-none bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">✨ Read Aloud</button>
                <button id="clearHighlightsBtn" class="flex-1 sm:flex-none bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Clear Highlights</button>
            </div>
            
            <div id="editor-container" class="border border-gray-300 rounded-lg p-4 focus-within:ring-2 focus-within:ring-blue-400 bg-gray-50">
                <div id="editor" contenteditable="true" aria-multiline="true" role="textbox" aria-label="Text editor"></div>
            </div>

            <div id="statusBar" class="text-sm text-gray-500 mt-2 h-6 flex items-center gap-2">
                <div id="loader" class="loader hidden"></div>
                <span id="statusText">Ready</span>
            </div>
            
            <!-- NEW: Audio Player -->
            <div id="audioPlayerContainer" class="mt-4 hidden">
                <audio id="audioPlayer" controls class="w-full"></audio>
            </div>
        </main>
        
        <!-- MODALS -->
        <div id="resultsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 id="modalTitle" class="text-xl font-bold">Results</h3>
                    <button id="closeModalBtn" class="text-gray-500 hover:text-gray-800 text-3xl leading-none">&times;</button>
                </div>
                <div id="modalContent" class="text-gray-700"></div>
            </div>
        </div>
        <div id="tooltip" class="tooltip">
            <div id="tooltipContent"></div>
            <div class="tooltip-arrow"></div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
        
        const editor = document.getElementById('editor');
        const statusText = document.getElementById('statusText');
        const loader = document.getElementById('loader');
        const fileUpload = document.getElementById('fileUpload');
        const fileNameDisplay = document.getElementById('fileName');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const audioPlayer = document.getElementById('audioPlayer');
        const actionButtons = document.querySelectorAll('.action-btn');
        const clearHighlightsBtn = document.getElementById('clearHighlightsBtn');
        const apiKeySection = document.getElementById('apiKeySection');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const resultsModal = document.getElementById('resultsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modalContent');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltipContent');

        let userApiKey = '';
        let originalTextMap = new Map();
        let suggestionCounter = 0;
        let currentAudioUrl = null;
        
        function setStatus(text, isLoading = false) {
            statusText.textContent = text;
            loader.classList.toggle('hidden', !isLoading);
        }

        fileUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            actionButtons.forEach(btn => btn.disabled = true);
            fileNameDisplay.textContent = `Loading: ${file.name}`;
            setStatus(`Processing ${file.name}...`, true);
            editor.textContent = '';
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';

            const reader = new FileReader();
            
            const onSuccess = (fileName) => {
                setStatus(`Successfully loaded ${fileName}. Ready to review.`);
                fileNameDisplay.textContent = `Loaded: ${fileName}`;
                if (userApiKey) actionButtons.forEach(btn => btn.disabled = false);
                setTimeout(() => progressContainer.classList.add('hidden'), 500);
            };

            const onError = (fileName, errorMsg) => {
                console.error(errorMsg);
                setStatus(`Error: Could not read ${fileName}.`);
                fileNameDisplay.textContent = `Failed to load: ${fileName}`;
                progressContainer.classList.add('hidden');
            };

            if (file.name.endsWith('.pdf')) {
                reader.onload = async (e) => {
                    try {
                        const pdf = await pdfjsLib.getDocument(e.target.result).promise;
                        let textContent = '';
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const text = await page.getTextContent();
                            textContent += text.items.map(s => s.str).join(' ') + '\n\n';
                            progressBar.style.width = `${(i / pdf.numPages) * 100}%`;
                        }
                        editor.textContent = textContent;
                        onSuccess(file.name);
                    } catch (error) {
                        onError(file.name, `Error parsing PDF: ${error}`);
                    }
                };
                reader.readAsArrayBuffer(file);
            } else if (file.name.endsWith('.docx')) {
                progressBar.style.width = '50%'; // Indeterminate progress for docx
                reader.onload = (e) => {
                    mammoth.extractRawText({ arrayBuffer: e.target.result })
                        .then(result => {
                            editor.textContent = result.value;
                            progressBar.style.width = '100%';
                            onSuccess(file.name);
                        })
                        .catch(error => {
                            onError(file.name, `Error parsing DOCX: ${error}`);
                        });
                };
                reader.readAsArrayBuffer(file);
            } else {
                onError(file.name, 'Unsupported file type.');
                setStatus('Error: Unsupported file type. Please upload a .pdf or .docx file.');
            }
        });
        
        function saveApiKey() { 
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                userApiKey = key;
                updateApiKeyUI(true);
                setStatus('API Key saved. Ready to use!');
            }
        }
        function updateApiKeyUI(isValid) {
            if (isValid) {
                apiKeySection.classList.replace('bg-red-100', 'bg-green-100');
                apiKeySection.classList.replace('border-red-300', 'border-green-300');
                apiKeyStatus.innerHTML = `API Key is saved and active. <a href="#" id="removeKeyLink" class="font-semibold underline">Remove</a>`;
                apiKeyStatus.classList.replace('text-red-700', 'text-green-800');
                document.getElementById('removeKeyLink')?.addEventListener('click', removeApiKey);
                apiKeyInput.style.display = 'none';
                saveApiKeyBtn.style.display = 'none';
                if (editor.textContent.trim()) {
                    actionButtons.forEach(btn => btn.disabled = false);
                } else {
                    actionButtons.forEach(btn => btn.disabled = true);
                }
            } else {
                apiKeySection.classList.replace('bg-green-100', 'bg-red-100');
                apiKeySection.classList.replace('border-green-300', 'border-red-300');
                apiKeyStatus.innerHTML = `To use the AI features, you need a free Google AI API key. <a href="https://aistudio.google.com/app/apikey" target="_blank" class="font-semibold underline hover:text-red-800">Get one here.</a>`;
                apiKeyStatus.classList.replace('text-green-800', 'text-red-700');
                apiKeyInput.style.display = 'block';
                saveApiKeyBtn.style.display = 'block';
                actionButtons.forEach(btn => btn.disabled = true);
                userApiKey = '';
            }
         }
        function removeApiKey(e) { 
            e.preventDefault();
            localStorage.removeItem('geminiApiKey');
            updateApiKeyUI(false);
            setStatus('API Key removed.');
        }
        function loadApiKey() { 
            const savedKey = localStorage.getItem('geminiApiKey');
            if (savedKey) {
                userApiKey = savedKey;
                updateApiKeyUI(true);
            } else {
                updateApiKeyUI(false);
            }
        }
        
        async function callGeminiAPI(model, payload, retries = 3, delay = 1000) {
            if (!userApiKey) { setStatus('Error: API Key is not set.'); return null; }
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${userApiKey}`;
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { const errorBody = await response.json(); const errorMsg = errorBody.error?.message || `HTTP error! status: ${response.status}`; throw new Error(errorMsg); }
                    return await response.json();
                } catch (error) {
                    console.error(`API call attempt ${i + 1} failed:`, error);
                    if (i === retries - 1) { setStatus(`Error: ${error.message}`); return null; }
                    await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
                }
            }
        }
        async function checkGrammarAndStyle() {
            const text = editor.textContent;
            if (!text.trim()) { setStatus('Editor is empty. Upload a file first.'); return; }
            setStatus('Checking grammar and style...', true);
            const systemPrompt = `You are a writing assistant. Analyze the text for spelling, grammar, and style errors. Respond with a JSON array of objects. Each object needs: "original", "suggestion", "type" ("highlight-spell" or "highlight-grammar"), and "explanation".`;
            const payload = { contents: [{ parts: [{ text: `Text: """${text}"""` }] }], systemInstruction: { parts: [{ text: systemPrompt }] }, generationConfig: { responseMimeType: "application/json" } };
            const result = await callGeminiAPI('gemini-2.5-flash-preview-05-20', payload);
            if (!result) return;
            const jsonResponse = result.candidates?.[0]?.content?.parts?.[0]?.text;
            try {
                const errors = JSON.parse(jsonResponse);
                if (errors.length === 0) return setStatus('No issues found.');
                const highlights = [];
                let currentIndex = 0;
                errors.forEach(error => {
                    const index = text.indexOf(error.original, currentIndex);
                    if (index !== -1) {
                        highlights.push({ ...error, index });
                        currentIndex = index + error.original.length;
                    }
                });
                clearHighlights();
                applyHighlights(highlights);
                setStatus(`${highlights.length} suggestions found. Click on highlights to see them.`);
            } catch (e) {
                console.error("Error parsing grammar JSON:", e, jsonResponse);
                setStatus('Error processing AI response.');
            }
        }
        async function checkPlagiarism() {
            const text = editor.textContent;
            if (!text.trim()) { setStatus('Editor is empty. Upload a file first.'); return; }
            setStatus('Checking for plagiarism...', true);
            const systemPrompt = "Analyze the text. Find sentences that might be plagiarized by searching for exact matches online. Return a JSON object: { 'plagiarismSources': [ { 'sentence': '...', 'source': '...' } ] }.";
            const payload = { contents: [{ parts: [{ text }] }], systemInstruction: { parts: [{ text: systemPrompt }] }, tools: [{ "google_search": {} }], generationConfig: { responseMimeType: "application/json" } };
            const result = await callGeminiAPI('gemini-2.5-flash-preview-05-20', payload);
            if (!result) return;
            const jsonResponse = result.candidates?.[0]?.content?.parts?.[0]?.text;
            try {
                const results = JSON.parse(jsonResponse);
                let modalHtml = `<p class="mb-4">This check looks for exact matches online. Common phrases may be flagged. Always verify the context.</p>`;
                if (results.plagiarismSources && results.plagiarismSources.length > 0) {
                    modalHtml += results.plagiarismSources.map(item => `<div class="mb-4 p-3 border rounded-lg bg-gray-50"><p class="font-semibold text-gray-800">Sentence:</p><blockquote class="pl-3 italic border-l-2 my-1">"${item.sentence}"</blockquote><p class="font-semibold text-gray-800 mt-2">Potential Source:</p><a href="${item.source}" target="_blank" class="text-blue-600 hover:underline break-all">${item.source}</a></div>`).join('');
                } else {
                    modalHtml += `<p class="text-green-600 font-semibold">No direct matches found online.</p>`;
                }
                showModal('Plagiarism Check Results', modalHtml);
            } catch (e) {
                console.error("Error parsing plagiarism JSON:", e);
                showModal('Error', '<p>Could not process the plagiarism check results.</p>');
            }
            setStatus('Plagiarism check complete.');
        }
        async function factCheck() {
            const text = editor.textContent;
            if (!text.trim()) { setStatus('Editor is empty. Upload a file first.'); return; }
            setStatus('Identifying and verifying facts...', true);
            const claimPrompt = `From the text, identify verifiable factual claims. Return a JSON object: { "claims": ["claim 1", "claim 2"] }. Text: """${text}"""`;
            const claimPayload = { contents: [{ parts: [{ text: claimPrompt }] }], generationConfig: { responseMimeType: "application/json" } };
            const claimResponse = await callGeminiAPI('gemini-2.5-flash-preview-05-20', claimPayload);
            if (!claimResponse) return;
            let claims;
            try { claims = JSON.parse(claimResponse.candidates?.[0]?.content?.parts?.[0]?.text).claims; } catch (e) { return setStatus('Could not identify facts to check.'); }
            if (!claims || claims.length === 0) return setStatus('No verifiable facts found in the text.');
            
            setStatus(`Found ${claims.length} claims. Verifying...`, true);
            const verificationPromises = claims.map(claim => {
                 const verifyPrompt = `Verify this claim: "${claim}". Provide a short summary, a confidence level ("Verified", "Uncertain", "False", etc.), and the top source URL. Respond in JSON format: {"claim": "...", "summary": "...", "confidence": "...", "source": "..."}`;
                 const verifyPayload = { contents: [{ parts: [{ text: verifyPrompt }] }], tools: [{ "google_search": {} }], generationConfig: { responseMimeType: "application/json" } };
                return callGeminiAPI('gemini-2.5-flash-preview-05-20', verifyPayload);
            });
            
            const results = await Promise.all(verificationPromises);
            let modalHtml = `<p class="mb-4">AI-powered fact-checking. Information may not be 100% accurate. Always verify sources.</p>`;
            results.forEach(res => {
                if (res) {
                    try {
                        const verification = JSON.parse(res.candidates?.[0]?.content?.parts?.[0]?.text);
                        const confidenceColor = {"Verified": "text-green-600 bg-green-100", "Likely True": "text-emerald-600 bg-emerald-100", "Uncertain": "text-yellow-600 bg-yellow-100", "Likely False": "text-orange-600 bg-orange-100", "False": "text-red-600 bg-red-100"}[verification.confidence] || "text-gray-600 bg-gray-100";
                        modalHtml += `<div class="mb-4 p-3 border rounded-lg"><p class="font-semibold">Claim:</p><blockquote class="pl-3 italic border-l-2 my-1">"${verification.claim}"</blockquote><p class="font-semibold mt-2">Verdict: <span class="font-bold px-2 py-1 rounded-md ${confidenceColor}">${verification.confidence}</span></p><p class="mt-1">${verification.summary}</p><p class="font-semibold mt-2">Source:</p><a href="${verification.source}" target="_blank" class="text-blue-600 hover:underline break-all">${verification.source}</a></div>`;
                    } catch (e) { console.error("Error parsing verification JSON:", e); }
                }
            });
            showModal('Fact-Check Results', modalHtml);
            setStatus('Fact-check complete.');
        }
        async function summarizeText() {
            const text = editor.textContent;
            if (!text.trim()) { setStatus('Editor is empty. Upload a file first.'); return; }
            setStatus('Summarizing text...', true);
            const systemPrompt = "Summarize the text into key bullet points using HTML list formatting (`<ul>` and `<li>`).";
            const payload = { contents: [{ parts: [{ text }] }], systemInstruction: { parts: [{ text: systemPrompt }] } };
            const result = await callGeminiAPI('gemini-2.5-flash-preview-05-20', payload);
            if (result) showModal('Summary', result.candidates?.[0]?.content?.parts?.[0]?.text);
            setStatus('Summary complete.');
        }
        async function readAloud() {
            const text = editor.textContent;
            if (!text.trim()) return setStatus('Editor is empty.');
            setStatus('Generating audio...', true);
            if(currentAudioUrl) URL.revokeObjectURL(currentAudioUrl);
            const payload = { contents: [{ parts: [{ text: `Say this naturally: ${text}` }] }], generationConfig: { responseModalities: ["AUDIO"] } };
            const result = await callGeminiAPI('gemini-2.5-flash-preview-tts', payload);
            const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            if (!audioData) return setStatus('Failed to generate audio.');
            try {
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16);
                currentAudioUrl = URL.createObjectURL(wavBlob);
                audioPlayer.src = currentAudioUrl;
                audioPlayerContainer.classList.remove('hidden');
                audioPlayer.play();
                setStatus('Playing audio.');
            } catch (e) {
                console.error("Error processing audio data:", e);
                setStatus('Error playing audio.');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadApiKey();
            saveApiKeyBtn.addEventListener('click', saveApiKey);
            document.getElementById('checkGrammarBtn').addEventListener('click', checkGrammarAndStyle);
            document.getElementById('plagiarismBtn').addEventListener('click', checkPlagiarism);
            document.getElementById('factCheckBtn').addEventListener('click', factCheck);
            document.getElementById('summarizeBtn').addEventListener('click', summarizeText);
            document.getElementById('readAloudBtn').addEventListener('click', readAloud);
            clearHighlightsBtn.addEventListener('click', clearHighlights);
            closeModalBtn.addEventListener('click', () => resultsModal.style.display = 'none');

            editor.addEventListener('click', (e) => {
                if (e.target.classList.contains('highlight')) {
                    const target = e.target;
                    const suggestion = target.dataset.suggestion;
                    const explanation = target.dataset.explanation;
                    let tooltipHtml = `<p class="text-sm text-gray-300">${explanation}</p><button class="suggestion-btn" onclick="applySuggestion('${target.id}', '${suggestion}')">${suggestion}</button>`;
                    showTooltip(target, tooltipHtml);
                    e.stopPropagation();
                }
            });
            document.addEventListener('click', (e) => { if (!tooltip.contains(e.target) || !e.target.closest('.highlight')) hideTooltip(); });
        });
        
        function showModal(title, content) { modalTitle.textContent = title; modalContent.innerHTML = content; resultsModal.style.display = 'flex'; }
        function showTooltip(targetElement, content) { tooltipContent.innerHTML = content; tooltip.style.display = 'block'; const rect = targetElement.getBoundingClientRect(); tooltip.style.left = `${rect.left + window.scrollX + (rect.width / 2) - (tooltip.offsetWidth / 2)}px`; tooltip.style.top = `${rect.bottom + window.scrollY + 5}px`; }
        function hideTooltip() { tooltip.style.display = 'none'; }
        function applySuggestion(spanId, suggestion) { const span = document.getElementById(spanId); if (span) { span.replaceWith(document.createTextNode(suggestion)); editor.normalize(); hideTooltip(); } }
        function applyHighlights(highlights) { let content = editor.textContent; let offset = 0; highlights.sort((a, b) => a.index - b.index); highlights.forEach(h => { suggestionCounter++; const id = `suggestion-${suggestionCounter}`; originalTextMap.set(id, h.original); const before = content.substring(0, h.index + offset); const original = content.substring(h.index + offset, h.original.length); const after = content.substring(h.index + offset + h.original.length); const span = `<span id="${id}" class="highlight ${h.type}" data-suggestion="${h.suggestion}" data-explanation="${h.explanation}">${original}</span>`; content = before + span + after; offset += span.length - h.original.length; }); editor.innerHTML = content; }
        function clearHighlights() { setStatus('Clearing highlights...'); editor.querySelectorAll('.highlight').forEach(span => { const originalText = originalTextMap.get(span.id) || span.textContent; span.replaceWith(document.createTextNode(originalText)); }); editor.normalize(); setStatus('Ready'); hideTooltip(); }
        
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }
        function pcmToWav(pcmData, sampleRate = 24000, channels = 1, bitsPerSample = 16) {
            const blockAlign = channels * (bitsPerSample / 8);
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            function writeString(view, offset, string) { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } }
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, channels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++, offset += 2) { view.setInt16(offset, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }
    </script>
</body>
</html>

